"""
TO build a YOLO DB
Input:
1) labelsheet_v3.csv: the category file with col 'EN_name', 'JP_name', 'parent', 'merge', 'country'
2) an source anno DB which stored in the format: name x y w h

Steps: @main()

Output:
1) category list@category.names -> should change to the task_name.names
2) an annotation DB with training category list,
3) training, validation file list
"""
import os
import shutil
from PIL import Image
from YOLODB_tools import get_file_list, DB_info_name_version, split_by_KFold, \
    id_to_name_conversion, id_to_name_conversion_for_intern_UEC, DB_info_id_version
import numpy as np
import operator
import pandas as pd


local = {
    'src_anno_dir':"/Users/fincep004/Documents/UEC256_annotations_YOLO_v2_name_c",
    'dst_anno_dir':"/Users/fincep004/Documents/UEC256_annotations_YOLO_v3_c",
    'IMG_DIR':''
}

gpu6 = {
    'src_anno_dir':'/mnt/UEC256_annotations_YOLO_v3_c', #UEC256_annotations_YOLO_v3_c
    'dst_anno_dir':"/mnt/UEC256_labels_exp", #UEC256_labels_exp
    'IMG_DIR':'/mnt/UEC256_images/'
}

gpu7 = {
    'src_anno_dir':'/mnt2/DB/finc_data/155_v3',
    'dst_anno_dir':"/mnt2/DB/finc_data/exp_labels_tmp",
    'IMG_DIR':'/mnt2/DB/finc_data/155'
}

server = gpu6

# skip if the nb of category is less than Min_num_list
Min_num_list = 95
DO_MERGE = True
skip_country_list = ['southeast_asia', 'Chinese', 'Hawaii', 'Korea', 'Taiwan']
skip_list = ['unknown_food', 'skip']



table = pd.read_csv('labelsheet_v3.csv', encoding='utf-8')
# remove NaN rows
table.dropna(how='all', inplace=True)
table.reset_index(drop=True, inplace=True)


def decide_category(src_anno_dir):
    """
    make category list by 'merge' or 'country'
    and store as 'exps/category.names'

    input: dict: {k(category_name):nb}
    :return: list of category
    """
    anno_dict = {}
    anno_list = get_file_list(src_anno_dir, extensions=('txt'))

    for f in anno_list:
        with open(f, 'r') as r:
            for line in r.readlines():
                food = line.rstrip().split(' ')[0]
                if food == 'nan':
                    print('nan @', f)
                    continue

                if food == 'skip' or food in skip_list:
                    print('skip {}@{}'.format(food, f))
                    continue

                # country filter
                if skip_country_list:
                    country = table[table['En_name'] == food]['country'].values[0]
                    if str(country) != 'nan' and country in skip_country_list:
                        continue

                # do merge
                if DO_MERGE:
                    new_name = table[table['En_name'] == food]['merge'].values[0]
                    if str(new_name) != 'nan':
                        # TODO: more pythonic
                        if new_name not in anno_dict:
                            anno_dict[new_name] = 1
                        else:
                            anno_dict[new_name] += 1
                    else:
                        # TODO: more pythonic
                        if food not in anno_dict:
                            anno_dict[food] = 1
                        else:
                            anno_dict[food] += 1
                else:
                    if food not in anno_dict:
                        anno_dict[food] = 1
                    else:
                        anno_dict[food] += 1

    print('total nb of category = ', len(anno_dict))

    category_list = []

    for k, v in sorted(anno_dict.items(), key=operator.itemgetter(1), reverse=True):
        if v < Min_num_list:
            print('discard the category which num is less than ', Min_num_list)
            break
        print(k, v)
        category_list.append(k)

    print('nb of new categories = ', len(category_list))

    with open('exps/category.names', 'w') as w:
        for c in category_list:
            w.write('{}\n'.format(c))

    return category_list


def make_YOLO_DB(src_anno_dir, dst_anno_dir, category_list):
    """
    make YOLO anno DB as dst_anno_dir from src_anno_dir by category_list,
    convert the category_name of src_anno_dir to label(num) and store in dst_anno_dir,
    according to category_list, which is generated by Make_category, a list contains category in this task
    :return:
    """
    anno_list = get_file_list(src_anno_dir, extensions=('.txt'))

    c = 0
    for f in anno_list:
        desired_annos = []
        #print(f)
        with open(f) as r:
            for l in r.readlines():
                pieces = l.rstrip().split(' ')
                # category
                v3_name = pieces[0].rstrip()
                #print('v3_name@',v3_name)

                if v3_name in skip_list:
                    continue

                if DO_MERGE:
                    # if this category is one of the category
                    if v3_name in category_list:
                        desired_annos.append('{} {} {} {} {}'.format(
                            category_list.index(v3_name), pieces[1], pieces[2], pieces[3], pieces[4]))
                        continue
                    new_name = table[table['En_name'] == v3_name]['merge'].values[0]
                    #print('new_name = ', new_name)
                    # if the merged category is one of the category
                    if str(new_name) != 'nan' and str(new_name) in category_list:
                        #print('merged: {} -> {}'.format(v3_name, new_name))
                        desired_annos.append('{} {} {} {} {}'.format(category_list.index(new_name), pieces[1], pieces[2], pieces[3], pieces[4]))
                else:
                    if v3_name not in category_list:
                        continue
                    #print('v3_name', v3_name)
                    desired_annos.append('{} {} {} {} {}'.format(category_list.index(v3_name), pieces[1], pieces[2], pieces[3], pieces[4]))
        if desired_annos:
            c += 1
            with open(os.path.join(dst_anno_dir, os.path.basename(f)), 'w') as w:
                for a in desired_annos:
                    #print(a)
                    w.write(a)
    print('nb of DB =', c)


def make_train_val_list(dst_anno_dir):
    """
    make train & val list for YOLO, and store as UEC256_train_test.txt, UEC256_val_test.txt
    """
    anno_list = get_file_list(dst_anno_dir, extensions=('.txt'))
    print(len(anno_list))
    train_list, val_list = split_by_KFold(anno_list, nb_splits=10)
    print(len(train_list))
    print(len(val_list))

    with open('exps/train_val/train_list.txt', 'w') as w:
        for f in train_list:
            id = os.path.splitext(os.path.basename(f))[0]
            w.write('{}\n'.format(os.path.join(server['IMG_DIR'], id + '.jpg')))

    with open('exps/train_val/val_list.txt', 'w') as w:
        for f in val_list:
            id = os.path.splitext(os.path.basename(f))[0]
            w.write('{}\n'.format(os.path.join(server['IMG_DIR'], id + '.jpg')))
    # !! after created, cp all files of UEC256_labels_exp to UEC256_images


def maker():
    # step0. check the DB info of src_anno_dir and get anno_dict
    # id_to_name_conversion_for_intern_UEC('/Users/fincep004/Documents/UEC256_annotations_YOLO_v2_c/',
    #                      '/Users/fincep004/Documents/UEC256_annotations_YOLO_v2_name_c/')
    # exit()

    # step1. check the DB info of src_anno_dir and get anno_dict
    # & decide new category list for new task
    new_category_list = decide_category(server['src_anno_dir'])
    # DB_info_id_version(server['dst_anno_dir'])

    # step2. make new anno DB by converting name of src_anno_dir -> label(num)
    make_YOLO_DB(server['src_anno_dir'], server['dst_anno_dir'],
                 new_category_list)

    # step3. based on dst_anno_dir to build DB
    make_train_val_list(server['dst_anno_dir'])

    # step4. check the DB by 1)DB_info_name_version
    # & 2)downloading & labelImg tool to check
    # DB_info_name_version(server['dst_anno_dir'])

    # step5. for YOLOv3@darknet,  copy *.txt to IMG_DIR


def make_food_only_DB(src_anno_dir, dst_anno_dir):
    anno_list = get_file_list(src_anno_dir, extensions=('.txt'))

    for f in anno_list:
        with open(f) as r:
            with open(os.path.join(dst_anno_dir, os.path.basename(f)), 'w') as w:
                for l in r.readlines():
                    pieces = l.rstrip().split(' ')
                    if pieces[0] == 'nonfood':
                        w.write('{} {} {} {} {}\n'.format(0, pieces[1], pieces[2],pieces[3], pieces[4]))
                        print('nonfood')
                    else:
                        w.write('{} {} {} {} {}\n'.format(1, pieces[1], pieces[2], pieces[3], pieces[4]))


def food_nonfood_maker():
    make_food_only_DB(server['src_anno_dir'], server['dst_anno_dir'])


def main():
    maker()



if __name__ == '__main__':
    main()









